#![no_std]

// Allow the code generated by bindgen to break style rules
#[allow(dead_code)]
#[allow(non_camel_case_types)]
#[allow(non_upper_case_globals)]
#[allow(non_snake_case)]
pub mod ffi;

use core::ffi::c_void;

type Mp3ptrT = *const u8;

pub use ffi::_MP3FrameInfo as MP3FrameInfo;

impl MP3FrameInfo {
    pub fn new() -> MP3FrameInfo {
        MP3FrameInfo {
            bitrate: 0,
            nChans: 0,
            samprate: 0,
            bitsPerSample: 0,
            outputSamps: 0,
            layer: 0,
            version: 0,
            size: 0,
        }
    }
}

impl Default for MP3FrameInfo {
    fn default() -> Self {
        Self::new()
    }
}
/// Errors that occur when calling the decode function
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub enum DecodeErr {
    Okay,
    InDataUnderflow,
    MaindataUnderfow,
    FreeBitrateSync,
    OutOfMemory,
    NullPointer,
    InvalidFrameheader,
    InvalidSideinfo,
    InvalidScalefact,
    InvalidHuffcodes,
    InvalidDequantize,
    InvalidImdct,
    InvalidSubband,
    Unknown,
    InvalidError,
}

impl From<i32> for DecodeErr {
    fn from(value: i32) -> Self {
        use DecodeErr::*;
        match value {
            0 => Okay,
            -1 => InDataUnderflow,
            -2 => MaindataUnderfow,
            -3 => FreeBitrateSync,
            -4 => OutOfMemory,
            -5 => NullPointer,
            -6 => InvalidFrameheader,
            -7 => InvalidSideinfo,
            -8 => InvalidScalefact,
            -9 => InvalidHuffcodes,
            -10 => InvalidDequantize,
            -11 => InvalidImdct,
            -12 => InvalidSubband,
            -9999 => Unknown,
            _ => InvalidError,
        }
    }
}
pub struct Mp3 {
    pub mp3dec: *mut c_void,
}

impl Mp3 {
    pub fn new() -> Mp3 {
        let dec = unsafe { crate::ffi::MP3InitDecoder() };
        Mp3 { mp3dec: dec }
    }

    // Find the offset of the next sync word in the MP3 stream. Use this to find the next frame
    pub fn find_sync_word(mp3buf: &[u8]) -> i32 {
        let mp3baseptr: Mp3ptrT = mp3buf.as_ptr();
        unsafe { crate::ffi::MP3FindSyncWord(mp3baseptr, mp3buf.len() as i32) }
    }

    // Get info for the last decoded MP3 frame
    pub fn get_last_frame_info(&mut self) -> MP3FrameInfo {
        let mut frame = MP3FrameInfo::new();
        unsafe { crate::ffi::MP3GetLastFrameInfo(self.mp3dec, &mut frame) };
        frame
    }

    // Get info for the next MP3 frame
    pub fn get_next_frame_info(&mut self, mp3buf: &[u8]) -> Result<MP3FrameInfo, DecodeErr> {
        let mut frame = MP3FrameInfo::new();
        let err =
            unsafe { crate::ffi::MP3GetNextFrameInfo(self.mp3dec, &mut frame, mp3buf.as_ptr()) };
        if err == 0 {
            // No error, return the frame info
            Ok(frame)
        } else {
            Err(err.into())
        }
    }

    /// Decode the next MP3 frame
    pub fn decode(&self, mp3buf: &[u8], newlen: i32, buf: &mut [i16]) -> Result<i32, DecodeErr> {
        let mut mp3baseptr: Mp3ptrT = mp3buf.as_ptr();
        let mut newlen = newlen;
        let err = unsafe {
            crate::ffi::MP3Decode(
                self.mp3dec,
                &mut mp3baseptr,
                &mut newlen,
                buf.as_mut_ptr(),
                0,
            )
        };
        if err == 0 {
            // No error, return the new length of the source buffer
            Ok(newlen)
        } else {
            Err(err.into())
        }
    }

    /// Expose underlying C void pointer HMP3Decoder. For when you need to use ffi functions that aren't wrapped
    ///
    /// # Safety
    ///
    /// use only with ffi::* from within this library
    pub unsafe fn ptr(&mut self) -> *mut c_void {
        self.mp3dec
    }
}

impl Default for Mp3 {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for Mp3 {
    fn drop(&mut self) {
        unsafe { crate::ffi::MP3FreeDecoder(self.mp3dec) }
    }
}
